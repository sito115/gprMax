#python:
import os
import numpy as np 
import sys
from thomas.python.generateRLFLA import antenna_like_RLFLA
from gprMax.input_cmd_funcs import *

# Model Settings
isRLFLA     = True   # use RLFLA or point antennae
is3D        = True   # use 3D Model or 2D [1 cell in y direction]
isGradient  = False  # include gradient in model
isSlice     = True  # use 2D slide for movies and geometry through feeding point of Antenna
# Geometry Settings
nSnaps      = 100
isGeometry  = True

nameIdentifier = ''  # to be included in title and geometry file

# Resolution / Grid Size
resolution  = 0.01
steps       = dx_dy_dz(resolution,resolution,resolution)

# Materials
er_0            = 12.5       
er_halfspace    = 5 
h               = 0.5
               
# Antenna Position
dx              = 6.0  # [m] TX-RX distance
buffer          = 0.4 # [m] buffer from each side of x-direction
nCellAboveInter = 2  # [m] antennas are placed above air soil interface  

# nRX
nRX            = 1
dxRX           = 0.2

# Antenna Parameters
antLength    = 0.6  # [m]
antFeedPoint = 0.26 # [m] from bottom of antenna
polari       = 'y'  # Polarisation       


airSoilInterface = 2.0    # air - halfspace interface

freqDipole       = 200e6  # Frequency of point source
nPml             = 20     # number of PML cells from each side of domain 

# Domain Geometries
xDim = 2*buffer + dx
yDim = 1.5
zDim = 3.0

########## Start of Model ##########  
if is3D:
    dim = domain(x=2*nPml*resolution + xDim, y=yDim + 2*nPml*resolution , z=zDim + 2*nPml*resolution)

    TXPos = (nPml*resolution + buffer,       0.5*dim[1]-antLength/2+antFeedPoint, airSoilInterface + nCellAboveInter * resolution)
    RXPos = (nPml*resolution + buffer + dx,  0.5*dim[1]-antLength/2+antFeedPoint, airSoilInterface + nCellAboveInter * resolution)

else:
    dim = domain(x=2*nPml*resolution + xDim, y=resolution,                z=zDim + 2*nPml*resolution)

    TXPos = (nPml*resolution + buffer,      0, airSoilInterface + nCellAboveInter * resolution)
    RXPos = (nPml*resolution + buffer + dx, 0, airSoilInterface + nCellAboveInter * resolution)

# Time & PML cells
tSim  = time_window(1e-7)   #(dim[0]/3e8*2)
command('pml_cells', nPml)


# Halfspace

material(permittivity=er_halfspace, conductivity=0, permeability=1, magconductivity=0, name='half_space')

# Boxes
box(xs=0, ys=0, zs=airSoilInterface,  xf=dim[0], yf=dim[1], zf=dim[2],           material='free_space')
box(xs=0, ys=0, zs=0,                 xf=dim[0], yf=dim[1], zf=airSoilInterface, material='half_space')


dirName = 'HalfSpace_dx%.1fm_eps_%.1f_i3D%d' %(dx,er_halfspace,is3D)

# Gradient
if isGradient:
    nLayers     = int(np.round(h / steps[2]) - 1)         # returns the nearest lower integer result
    deltaEr     = (er_halfspace - er_0) / nLayers

    dirName += '_er0_%.1f_h%.1fm' %(er_0, h)

    for iLayer in range(nLayers):
        material(permittivity=er_0 + iLayer*deltaEr, conductivity=0, permeability=1, magconductivity=0,
                 name='layer' + str(iLayer+1))
        box(0     , 0     , airSoilInterface - (iLayer + 1)*steps[2],   # lower end
            dim[0], dim[1], airSoilInterface - iLayer * steps[2]    , material='layer' + str(iLayer+1))
        
    # update names
    if er_0 > er_halfspace:
        dirName += 'Decrease'
    elif er_0 < er_halfspace:
        dirName += 'Increase'
    else:
        dirName += 'NoGrad'

#### Y-polar
if isRLFLA:
    antenna_like_RLFLA(x=TXPos[0],y=TXPos[1],z=TXPos[2],            # TX
                    resolution=resolution, polarisation=polari,
                    ID='RLFLA-TX', isTx=True)
    
    dirName += 'RLFLA'
 
    for iRX in range(nRX): # RX
            antenna_like_RLFLA(x=RXPos[0]-iRX*dxRX,y=RXPos[1],z=RXPos[2],
                resolution=resolution, polarisation=polari,
                ID='RLFLARx' + str(iRX), isTx=False)


else:
    waveID  = waveform('gaussian', amplitude=1,
                    frequency=freqDipole, identifier='GausDipole')
    hertzian_dipole(polarisation=polari, f1=TXPos[0],
                    f2=TXPos[1], f3=TXPos[2], identifier=waveID)
    
    for iRX in range(nRX): # RX
        rx(x=RXPos[0]-iRX*dxRX, y=RXPos[1], z=RXPos[2])

    dirName += 'InfDip'


# Set Directory and Title name
if nRX > 1:
    dirName += 'nRX%d_dxRX%.2fm' %(nRX, dxRX)

dirName += nameIdentifier 
command('title', dirName)

# Geometry
if isGeometry:
    if isSlice:
        geometry_view(0,TXPos[1],0,dim[0], TXPos[1]+steps[1], dim[2],
                    resolution, resolution, resolution, dirName, 'n')
    else:
        geometry_view(0,0,0,dim[0], dim[1], dim[2],
                    resolution, resolution, resolution, dirName, 'n')

# Snapshots
if nSnaps > 0:
    dt = tSim/nSnaps 
    # set dt to 0.5e-9
    name = 'snap' + dirName + 'dt_%.2e_' %(dt)
    if isSlice:
        for i in range(1, nSnaps+1):
            snapshot(0, RXPos[1], 0,
                    dim.x, RXPos[1] + steps[1], dim.z,
                    steps[0], steps[1], steps[2],
                    i*dt, name + str(i))
    else:
        for i in range(1, nSnaps+1):
            snapshot(0, 0, 0,
                    dim.x, dim.y, dim.z,
                    steps[0], steps[1], steps[2],
                    i*dt, name + str(i))

###################
#end_python: